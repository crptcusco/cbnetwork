import logging
import copy
import sys
from cbnetwork.cbnetwork import CBN
from cbnetwork.directededge import DirectedEdge
from cbnetwork.internalvariable import InternalVariable
from cbnetwork.localnetwork import LocalNetwork
from cbnetwork.utils.customtext import CustomText

# 1. Setup Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(message)s',
    stream=sys.stdout
)

def create_scaled_networks():
    # Net 1: [1..10], depends on Signal 32 (from Net 3)
    # Net 2: [11..20], depends on Signal 31 (from Net 1)
    # Net 3: [21..30], no dependencies
    
    # We create a CHAIN of dependencies: i(t+1) = i-1(t)
    # This prevents the 2^(n-1) attractor explosion.

    # --- NETWORK 3 (Source for 32) ---
    d_net3_vars = {21: [[-21]]} # Var 21 oscillates
    for i in range(22, 31):
        d_net3_vars[i] = [[i-1]] # Chain: 22 depends on 21, 23 on 22...
    ln3 = LocalNetwork(3, list(range(21, 31)))
    for v, cnf in d_net3_vars.items():
        ln3.descriptive_function_variables.append(InternalVariable(v, cnf))

    # --- NETWORK 1 (Source for 31, Dest for 32) ---
    d_net1_vars = {1: [[32]]} # Var 1 = Signal 32
    for i in range(2, 11):
        d_net1_vars[i] = [[i-1]] # Chain
    ln1 = LocalNetwork(1, list(range(1, 11)))
    for v, cnf in d_net1_vars.items():
        ln1.descriptive_function_variables.append(InternalVariable(v, cnf))
    
    # --- NETWORK 2 (Dest for 31) ---
    d_net2_vars = {11: [[31]]} # Var 11 = Signal 31
    for i in range(12, 21):
        d_net2_vars[i] = [[i-1]] # Chain
    ln2 = LocalNetwork(2, list(range(11, 21)))
    for v, cnf in d_net2_vars.items():
        ln2.descriptive_function_variables.append(InternalVariable(v, cnf))

    # --- COUPLING EDGES ---
    # Signal 31: 1 -> 2 (uses vars from Net 1)
    edge_31 = DirectedEdge(
        index=1,
        index_variable_signal=31,
        input_local_network=2,
        output_local_network=1,
        l_output_variables=[1, 10],
        coupling_function=" 1 ∧ 10 "
    )
    
    # Signal 32: 3 -> 1 (uses vars from Net 3)
    edge_32 = DirectedEdge(
        index=2,
        index_variable_signal=32,
        input_local_network=1,
        output_local_network=3,
        l_output_variables=[21, 30],
        coupling_function=" 21 ∨ 30 "
    )
    
    return [ln1, ln2, ln3], [edge_31, edge_32]

def print_detailed_report(networks, edges, method_name):
    print(f"\n{'='*80}")
    print(f" DETAILED REPORT: {method_name} (3 NETS, 10 VARS EACH)")
    print(f"{'='*80}")
    
    for net in sorted(networks, key=lambda x: x.index):
        print(f"\n>>> LOCAL NETWORK {net.index}")
        print(f"    Variables: {net.internal_variables}")
        print(f"    Signals acting on this network: {net.external_variables}")
        print(f"    Logic (Variables & CNF):")
        for var in net.descriptive_function_variables:
            print(f"      Var {var.index:2} -> CNF: {var.cnf_function}")
        
        # Output signals generated by this network
        out_signals = [e for e in edges if e.output_local_network == net.index]
        if out_signals:
            print(f"    Output Signals generated by this net:")
            for s in out_signals:
                print(f"      Signal {s.index_variable} (ID {s.index}): {s.coupling_function} using {s.l_output_variables}")

        print(f"    Attractors per Scene:")
        for scene_obj in net.local_scenes:
            scene_str = "".join(scene_obj.l_values) if scene_obj.l_values else "None"
            num_attr = len(scene_obj.l_attractors)
            print(f"      Scene [{scene_str}]: {num_attr} attractor(s) found.")
            for i, attr in enumerate(scene_obj.l_attractors):
                states = ["".join(str(v) for v in s.l_variable_values[:len(net.internal_variables)]) for s in attr.l_states]
                print(f"        Attr {i+1:2} (len={len(states)}): {states if len(states) <= 2 else states[:2] + ['...']}")

# --- EXECUTION ---
l_nets, l_edges = create_scaled_networks()

# 4. RUN BRUTE FORCE
nets_bf = copy.deepcopy(l_nets)
edges_bf = copy.deepcopy(l_edges)

for net in nets_bf:
    input_signals = [e for e in edges_bf if e.input_local_network == net.index]
    net.process_input_signals(input_signals)

LocalNetwork.find_local_attractors_brute_force(nets_bf[0], local_scenes=[['0'], ['1']])
LocalNetwork.find_local_attractors_brute_force(nets_bf[1], local_scenes=[['0'], ['1']])
LocalNetwork.find_local_attractors_brute_force(nets_bf[2], local_scenes=[[]])

# 5. RUN SAT
nets_sat = copy.deepcopy(l_nets)
edges_sat = copy.deepcopy(l_edges)
for net in nets_sat:
    input_signals = [e for e in edges_sat if e.input_local_network == net.index]
    net.process_input_signals(input_signals)

o_cbn = CBN(nets_sat, edges_sat)
o_cbn.find_local_attractors_sequential()

# 6. SHOW REPORTS
print_detailed_report(nets_bf, edges_bf, "BRUTE FORCE METHOD")
print_detailed_report(o_cbn.l_local_networks, edges_sat, "NORMAL (SAT) METHOD")

# 7. FINAL COMPARISON
def extract_summary(networks):
    s = ""
    for n in sorted(networks, key=lambda x: x.index):
        s += f"NET{n.index}:"
        for sc in sorted(n.local_scenes, key=lambda x: "".join(x.l_values)):
            num_attr = len(sc.l_attractors)
            attr_lens = sorted([len(a.l_states) for a in sc.l_attractors])
            s += f" S{''.join(sc.l_values)}:{num_attr}AT({attr_lens});"
    return s

bf_sum = extract_summary(nets_bf)
sat_sum = extract_summary(o_cbn.l_local_networks)

print("\n" + "="*80)
if bf_sum == sat_sum:
    print(" VERIFICATION SUCCESS: Both methods are 100% consistent for 3-nets, 30 variables!")
else:
    print(" VERIFICATION FAILURE: Mismatch detected!")
    print(f"  BF:  {bf_sum}")
    print(f"  SAT: {sat_sum}")
print("="*80 + "\n")
